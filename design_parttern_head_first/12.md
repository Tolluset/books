# 12장

## 이야깃거리

- 추상 클래스 vs 인터페이스, 언제 어떻게 다뤄야할까

- 옵저버 패턴을 사용하면 각 클래스에 변경이 생기고 옵저버블 클래스와 결합이 생기는데 피할 수 없을까?

- 좋은 디자인 패턴 예제들

- MVC는 왜 그렇게 유명하고 MVVC, MVP 등등 파생된게 많을까? 과거의 어떤 문제를 해결했던 걸까?

- MVC에서 컨트롤러는 어떻게 테스트해야할까?

- 하나의 컨트롤러가 다른 컨트롤러를 재사용하기 위해 어댑터 패턴을 사용하는게 과연 좋은 방법일까?

- 객체지향의 원칙 중 "어떤 클래스가 바뀌는 이유는 하나뿐이어야만 한다" 에 컨트롤러는 예외일까?

## 요약

- 어댑터 패턴
  - 인터페이스가 다르지만 다른 객체의 특정 메소드와 호환 가능해 보이는 경우 인터페이스를 변환 시켜준다

```java
public class GooseAdapter implements Quackable {
    Goose goose;

    public GooseAdapter(Goose goose) {
        this.goose = goose;
      }

    public void quack() {
        goose.honk();
      }
  }
```

- 데코레이터 패턴

  - 특정 인터페이스의 객체들의 특정 메소드를 변경하지 않고 특정 메소드가 동작시에 추가 작업을 가능하게 해줌

- 추상 팩토리 패턴

  - 팩토리를 추상 클래스로 만들어 각각의 객체를 만드는 메소드를 구현하는 여러 팩토리를 만들 수 있게 한다.
    - 이렇게 하면 특정 데코레이터로 감싸고 있는 팩토리라던지 자유롭게 변경이 가능하고, 사용하는 쪽에서는 추상 팩토리의 타입으로 받는다면 교환도 자유롭다.
  - 추상 클래스 vs 인터페이스
    - https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-vs-%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%B0%A8%EC%9D%B4%EC%A0%90-%EC%99%84%EB%B2%BD-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0

- 컴포지드 패턴

  - 같은 인터페이스를 지니는 여러 객체들을 컬렉션으로서 관리하는 패턴

- 옵저버 패턴
  - 클래스의 메소드가 실행될 때 등록된 옵저버가 해당 객체의 메소드 실행을 알 수 있게 해줌
